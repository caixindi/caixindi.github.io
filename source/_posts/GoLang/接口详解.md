### 什么是接口

在Go语言中还存在着另外一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出**它们自己的方法**。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。

先通过Java程序来举个例子:

```java
/* 文件名 : Animal.java */
interface Animal {
   public void eat();
   public void travel();
}
```

```go
/* 文件名 : Dog.java */
public class Dog implements Animal{
 
   public void eat(){
      System.out.println("Dog eats");
   }
 
   public void sleep(){
      System.out.println("Dog sleep");
   } 
  
   public static void main(String args[]){
      Dog d = new Dog();
      d.eat();
      d.sleep();
   }
}
```

在Java中实现接口的方式是显示的，关键词为`implements`

但是在Golang中，接口的实现不需要显示声明，只要实现了接口的所有方法，则默认实现了该接口。Golang中声明一个接口类型，可以这么写：

```go
type Animal interface {
    eat() 
    sleep()
}
```

### Golang interface 的理解

因为Go本身并没有类和继承的概念，Go就是借助接口来实现多态，一个类型可以实现多个接口，一个接口也可以被多个类型实现。Go 接口是一组方法的集合，可以理解为**抽象的类型**。它提供了一种非侵入式的接口。任何类型，只要实现了该接口中方法集，那么就属于这个类型。需要注意的是，虽然接口解除了类型依赖，有助于减少用户的可视方法，屏蔽了内部结构和实现细节，但是接口不能滥用，不能说定义的所有接口，每个都仅仅只有一个实现，那么这大可不必，这样做反而会增加运行时损耗。

### 简单接口的实现

```go
package main

type Animal interface {
	eat()
	sleep()
}

type Dog struct {
	name string
}

func (dog *Dog) eat() {
	println(dog.name + " is eating")
}
func (dog *Dog) sleep() {
	println(dog.name + " is sleeping")
}

func main() {
	var a Animal
	d := &Dog{name: "qiqi"}
	//由于Dog实现了Animal接口，所以可以直接赋值
	a = d
	a.eat() //输出 qiqi is eating
	a.sleep() //输出 qiqi is sleeping
}
```

