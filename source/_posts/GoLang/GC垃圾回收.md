基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但是这个选择并不是由用var还是new声明变量的方式决定的。如同下面这段代码：

```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

f函数里的变量必须在堆上分配，虽然它在函数的内部定义，但是因为它在f函数结束调用后，依然可以通过包一级的global变量找到，也就是局部变量从函数f中逃逸了。而对于g函数，当它结束调用的时，变量`*y`将不可达，也就是说可以马上把被回收，因此编译器可以选择在栈上分配`*y`的存储空间。(当然也可以选择在堆上分配)

