https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/

为什么双指针的做法是正确的？

> 双指针代表了什么?

双指针代表的是**可以作为容器边界的所有位置的范围**。在一开始，双指针指向数组的左右边界，**表示数组中所有的位置都可以作为容器的边界**，因为这时还没有进行过任何的尝试。在这之后，每次将**对应的数字较小的那个指针往另一个个指针的方向移动一个位置**，就表示这个指针**不可能再作为容器的边界了**。

> 为什么对应数字较小的那个指针不可能再作为容器的边界了？

**考虑第一步**，假设当前左指针和右指针指向的数分别为$x$和$y$，不失一般性，我们假设$x\leq y$。同时，两个指针之间的距离为$t$。那么，它们组成的容器的容量为：
$$
\min(x,y)*t=x*t
$$
我们可以断定，**如果我们保持左指针的位置不变，那么无论右指针在哪里，这个容器的容量都不会超过 **$x*t $**了**。注意这里右指针只能向左移动，因为我们考虑的是第一步，也就是指针还指向数组的左右边界的时候。

此时我们任意向左移动右指针，指向的数为$y_1$，两个指针之间的距离为$t_1$，那么显然有$t_1<t$，并且$\min(x,y_1)\leq \min(x,y)$：

- 如果$y_1\leq y$，那么$min(x,y_1)\leq \min(x,y)$
- 如果$y_1\geq y$，那么$min(x,y_1)= x=\min(x,y)$

因此有：
$$
\min(x,y_t)*t_1<\min(x,y)*t
$$
即无论怎么移动右指针，得到容器的容量都小于移动前容器的容量。也就是说，**这个左指针对应的数不会作为容器的边界了**，那么我们就可以丢弃这个位置，**将左指针向右移动一个位置**，此时新的左指针于原先的右指针之间的左右位置，才可能会作为容器的边界。

这样一来，问题的规模减小了1，被丢弃的那个位置相当于消失了。**此时的左右指针，就指向了一个新的规模减少了的问题数组的左右边界**，因此，我们可以继续重复之前的步骤去解决该问题：

- 求出当前双指针对应的容器的容量
- 对应数字较小的那个指针以后不可能作为容器的边界，将其丢弃，并且移动到新的位置。

> 最后的结果是什么？

结果就是我们每次以双指针为左右边界（也就是数组的左右边界）计算出的容器容量的最大值。

```java
public class Solution {
    public int maxArea(int[] height) {
        int l = 0, r = height.length - 1;
        int ans = 0;
        while (l < r) {
            int area = Math.min(height[l], height[r]) * (r - l);
            ans = Math.max(ans, area);
            if (height[l] <= height[r]) {
                ++l;
            }
            else {
                --r;
            }
        }
        return ans;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(N)$，双指针总计最多遍历整个数组一次。
- 空间复杂度：$O(1)$，只需要额外的常数级别的空间。

